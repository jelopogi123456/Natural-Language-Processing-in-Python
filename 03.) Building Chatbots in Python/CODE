EchoBot I
Hello, World!

You'll begin learning how to build chatbots in Python by writing two functions to build the simplest bot possible: EchoBot. EchoBot just responds by replying with the same message it receives.

In this exercise, you'll define a function that responds to a user's message. In the next exercise, you'll complete EchoBot by writing a function to send a message to the bot.

Instructions
100 XP
Write a function called respond() with a single parameter message which returns the bot's response. To do this, concatenate the strings "I can hear you! You said: " and message.
Store the concatenated strings in bot_message, and return this result


bot_template = "BOT : {0}"
user_template = "USER : {0}"

# Define a function that responds to a user's message: respond
def respond(message):
    # Concatenate the user's message to the end of a standard bot respone
    bot_message = "I can hear you! You said: {}".format(message)
    # Return the result
    return bot_message

# Test function
print(respond("hello!"))

EchoBot II
Having written your respond() function, you'll now define a function called send_message() with a single parameter message which logs the message and the bot's response.

Instructions
100 XP
Use the user_template string's .format() method to include the user's message into the user template, and print the result.
Call the respond() function with the message passed in and save the result as response.
Log the bot's response using the bot_template string's .format() method.
Send the message "hello" to the bot.


# Create templates
bot_template = "BOT : {0}"
user_template = "USER : {0}"

# Define a function that sends a message to the bot: send_message
def send_message(message):
    # Print user_template including the user_message
    print(user_template.format(message))
    # Get the bot's response to the message
    response = respond(message)
    # Print the bot template including the bot's response.
    print(bot_template.format(response))

# Send a message to the bot
send_message("hello")


Chitchat
Now you're going to leave the simple EchoBot behind and create a bot which can answer simple questions such as "What's your name?" and "What's today's weather?"

You'll use a dictionary with these questions as keys and the correct responses as values.

This means the bot will only respond correctly if the message matches exactly, which is a big limitation. In later exercises you will create much more robust solutions.

The send_message() function has already been defined for you, as well as the bot_template and user_template variables.

Instructions 1/2
50 XP
Define a respond() function which takes in a message argument, checks if the message has a pre-defined response, and returns the response in the responses dictionary if there is a match, or the "default" message otherwise.


# Define variables
name = "Greg"
weather = "cloudy"

# Define a dictionary with the predefined responses
responses = {
  "what's your name?": "my name is {0}".format(name),
  "what's today's weather?": "the weather is {0}".format(weather),
  "default": "default message"
}

# Return the matching response if there is one, default otherwise
def respond(message):
    # Check if the message is in the responses
    if message in responses:
        # Return the matching message
        bot_message = responses[message]
    else:
        # Return the "default" message
        bot_message = responses["default"]
    return bot_message
    
    
    Well Done! Your bot is now able to answer some simple questions. Hit 'Run Code' and call send_message() (which utilizes the new respond() function) in the IPython Shell with the following questions:
"what's today's weather?"
"what's your name?"
"what's your favorite color?"
Hit 'Submit Answer' when you are done.


# Define variables
name = "Greg"
weather = "cloudy"

# Define a dictionary with the predefined responses
responses = {
  "what's your name?": "my name is {0}".format(name),
  "what's today's weather?": "the weather is {0}".format(weather),
  "default": "default message"
}

# Return the matching response if there is one, default otherwise
def respond(message):
    # Check if the message is in the responses
    if message in responses:
        # Return the matching message
        bot_message = responses[message]
    else:
        # Return the "default" message
        bot_message = responses["default"]
    return bot_message

send_message("what's today's weather?")


Adding variety
It can get a little boring hearing the same old answers over and over. In this exercise, you'll add some variation. If you ask your bot how it's feeling, the likelihood that it responds with "oh I'm great!" or "I'm very sad today" should be equal.

Here, you'll use the random module - specifically random.choice(ls) - which randomly selects an element from a list ls.

A dictionary called responses, which maps each message to a list of possible responses, has been defined for you.

Instructions 1/2
50 XP
Import the random module.
If the message is in responses, use random.choice() in the respond() function to choose a random matching response.
If the message is not in responses, choose a random default response.


# Import the random module
import random

name = "Greg"
weather = "cloudy"

# Define a dictionary containing a list of responses for each message
responses = {
  "what's your name?": [
      "my name is {0}".format(name),
      "they call me {0}".format(name),
      "I go by {0}".format(name)
   ],
  "what's today's weather?": [
      "the weather is {0}".format(weather),
      "it's {0} today".format(weather)
    ],
  "default": ["default message"]
}

# Use random.choice() to choose a matching response
def respond(message):
    # Check if the message is in the responses
    if message in responses:
        # Return a random matching response
        bot_message = random.choice(responses[message])
    else:
        # Return a random "default" response
        bot_message = random.choice(responses["default"])
    return bot_message
    
    
    Great job! Adding some variety makes your bot much more fun to talk to. Now, hit 'Run Code' and use send_message() (which utilizes the new respond() function) to ask the bot "what's your name?" 3 times.
Hit 'Submit Answer' when you're done.


# Import the random module
import random

name = "Greg"
weather = "cloudy"

# Define a dictionary containing a list of responses for each message
responses = {
  "what's your name?": [
      "my name is {0}".format(name),
      "they call me {0}".format(name),
      "I go by {0}".format(name)
   ],
  "what's today's weather?": [
      "the weather is {0}".format(weather),
      "it's {0} today".format(weather)
    ],
  "default": ["default message"]
}

# Use random.choice() to choose a matching response
def respond(message):
    if message in responses:
        bot_message = random.choice(responses[message])
    else:
        bot_message = random.choice(responses["default"])
    return bot_message

send_message("what's your name?")


ELIZA I: asking questions
Asking questions is a great way to create an engaging conversation. Here, you'll create the very first hint of ELIZA's famous personality, by responding to statements with a question and responding to questions with answers.

A dictionary of responses with "question" and "statement" as keys and lists of appropriate responses as values has already been defined for you. Explore this in the Shell with responses.keys() and responses["question"].

Instructions
100 XP
Define a respond() function which takes in message as an argument, and uses the string's .endswith() method to check if a message ends with a question mark.
If the message does end with a question mark, choose a random "question" from the responses dictionary. Else, choose a random "statement" from the responses.
Send the bot multiple messages with and without a question mark - these have been provided for you. If you want to experiment further in the Shell, be sure to first hit 'Run Code'.

import random

def respond(message):
    # Check for a question mark
    if message.endswith("?"):
        # Return a random question
        return random.choice(responses["question"])
    # Return a random statement
    return random.choice(responses["statement"])


# Send messages ending in a question mark
send_message("what's today's weather?")
send_message("what's today's weather?")

# Send messages which don't end with a question mark
send_message("I love building chatbots")
send_message("I love building chatbots")



ELIZA II: Extracting key phrases
The really clever thing about ELIZA is the way the program appears to understand what you told it by occasionally including phrases uttered by the user in its responses.

In this exercise, you will match messages against some common patterns and extract phrases using re.search(). A dictionary called rules has already been defined, which matches the following patterns:

"do you think (.*)"
"do you remember (.*)"
"I want (.*)"
"if (.*)"
Inspect this dictionary in the Shell before starting the exercise.

Instructions
100 XP
Iterate over the rules dictionary using its .items() method, with pattern and responses as your iterator variables.
Use re.search() with the pattern and message to create a match object.
If there is a match, use random.choice() to pick a response.
If '{0}' is in that response, use the match object's .group() method with index 1 to retrieve a phrase.


# Define match_rule()
def match_rule(rules, message):
    response, phrase = "default", None
    
    # Iterate over the rules dictionary
    for pattern, responses in rules.items():
        # Create a match object
        match = re.search(pattern,message)
        if match is not None:
            # Choose a random response
            response = random.choice(responses)
            if '{0}' in response:
                phrase = match.group(1)
    # Return the response and phrase
    return response.format(phrase)

# Test match_rule
print(match_rule(rules, "do you remember your last birthday"))


ELIZA III: Pronouns
To make responses grammatically coherent, you'll want to transform the extracted phrases from first to second person and vice versa. In English, conjugating verbs is easy, and simply swapping "me" and 'you', "my" and "your" works in most cases.

In this exercise, you'll define a function called replace_pronouns() which uses re.sub() to map "me" and "my" to "you" and "your" (and vice versa) in a string.

Instructions
100 XP
If 'me' is in message, use re.sub() to replace it with 'you'.
If 'my' is in message, replace it with 'your'.
If 'your' is in message, replace it with 'my'.
If 'you' is in message, replace it with 'me'.

# Define replace_pronouns()
def replace_pronouns(message):

    message = message.lower()
    if 'me' in message:
        # Replace 'me' with 'you'
        return re.sub('me', 'you' , message)
    if 'my' in message:
        # Replace 'my' with 'your'
        return re.sub('my', 'your' , message)
    if 'your' in message:
        # Replace 'your' with 'my'
        return re.sub('your', 'my' , message)
    if 'you' in message:
        # Replace 'you' with 'me'
        return re.sub('you', 'me' , message)

    return message

print(replace_pronouns("my last birthday"))
print(replace_pronouns("when you went to Florida"))
print(replace_pronouns("I had my own castle"))


ELIZA IV: Putting it all together
Now you're going to put everything from the previous exercises together and experience the magic! The match_rule(), send_message(), and replace_pronouns() functions have already been defined, and the rules dictionary is available in your workspace.

Your job here is to write a function called respond() with a single argument message which creates an appropriate response to be handled by send_message().

Instructions
100 XP
Get a response and phrase by calling match_rule() with the rules dictionary and message.
Check if the response is a template by seeing if it includes the string '{0}'. If it does:
Use the replace_pronouns() function on phrase.
Include the phrase by using .format() on response and overriding the value of response.
Hit 'Submit Answer' to see how the bot responds to the provided messages!


# Define respond()
def respond(message):
    # Call match_rule
    response, phrase = match_rule(rules,message)
    if '{0}' in response:
        # Replace the pronouns in the phrase
        phrase = replace_pronouns(phrase)
        # Include the phrase in the response
        response = response.format(phrase)
    return response

# Send the messages
send_message("do you remember your last birthday")
send_message("do you think humans should be worried about AI")
send_message("I want a robot friend")
send_message("what if you could be anything you wanted")


Intent classification with regex I
You'll begin by implementing a very simple technique to recognize intents - looking for the presence of keywords.

A dictionary, keywords, has already been defined. It has the intents "greet", "goodbye", and "thankyou" as keys, and lists of keywords as the corresponding values. For example, keywords["greet"] is set to "["hello","hi","hey"].

Also defined is a second dictionary, responses, indicating how the bot should respond to each of these intents. It also has a default response with the key "default".

The function send_message(), along with the bot and user templates, have also already been defined. Your job in this exercise is to create a dictionary with the intents as keys and regex objects as values.

Instructions
100 XP
Iterate over the keywords dictionary, using intent and keys as your iterator variables.
Use '|'.join(keys) to create regular expressions to match at least one of the keywords and pass it to re.compile() to compile the regular expressions into pattern objects. Store the result as the value of the patterns dictionary.

# Define a dictionary of patterns
patterns = {}

# Iterate over the keywords dictionary
for intent, keys in keywords.items():
    # Create regular expressions and compile them into pattern objects
    patterns[intent] = re.compile('|'.join(keys))
    
# Print the patterns
print(patterns)


Intent classification with regex II
With your patterns dictionary created, it's now time to define a function to find the intent of a message.

Instructions
100 XP
Iterate over the intents and patterns in the patterns dictionary using its .items() method.
Use the .search() method of pattern to look for keywords in the message.
If there is a match, return the corresponding intent.
Call your match_intent() function inside respond() with message as the argument and then hit 'Submit Answer' to see how the bot responds to the provided messages.


# Define a function to find the intent of a message
def match_intent(message):
    matched_intent = None
    for intent, pattern in patterns.items():
        # Check if the pattern occurs in the message 
        if pattern.search(message):
            matched_intent = intent
    return matched_intent

# Define a respond function
def respond(message):
    # Call the match_intent function
    intent = match_intent(message)
    # Fall back to the default response
    key = "default"
    if intent in responses:
        key = intent
    return responses[key]

# Send messages
send_message("hello!")
send_message("bye byeee")
send_message("thanks very much!")


Entity extraction with regex
Now you'll use another simple method, this time for finding a person's name in a sentence, such as "hello, my name is David Copperfield".

You'll look for the keywords "name" or "call(ed)", and find capitalized words using regex and assume those are names. Your job in this exercise is to define a find_name() function to do this.

Instructions
100 XP
Use re.compile() to create a pattern for checking if "name" or "call" keywords occur.
Create a pattern for finding capitalized words.
Use the .findall() method on name_pattern to retrieve all matching words in message.
Call your find_name() function inside respond() and then hit 'Submit Answer' to see how the bot responds to the provided messages.


# Define find_name()
def find_name(message):
    name = None
    # Create a pattern for checking if the keywords occur
    name_keyword = re.compile('name|call')
    # Create a pattern for finding capitalized words
    name_pattern = re.compile('[A-Z]{1}[a-z]*')
    if name_keyword.search(message):
        # Get the matching words in the string
        name_words = name_pattern.findall(message)
        if len(name_words) > 0:
            # Return the name if the keywords are present
            name = ' '.join(name_words)
    return name

# Define respond()
def respond(message):
    # Find the name
    name = find_name(message)
    if name is None:
        return "Hi there!"
    else:
        return "Hello, {0}!".format(name)

# Send messages
send_message("my name is David Copperfield")
send_message("call me Ishmael")
send_message("People call me Cassandra")


word vectors with spaCy
In this exercise you'll get your first experience with word vectors! You're going to use the ATIS dataset, which contains thousands of sentences from real people interacting with a flight booking system.

The user utterances are available in the list sentences, and the corresponding intents in labels.

Your job is to create a 2D array X with as many rows as there are sentences in the dataset, where each row is a vector describing that sentence.

Instructions
100 XP
Load the spaCy English model by calling spacy.load() with argument 'en'.
Calculate the length of sentences using len() and the dimensionality of the word vectors using nlp.vocab.vectors_length.
For each sentence, call the nlp object with the sentence as the sole argument. Store the result as doc.
Use the .vector attribute of doc to get the vector representation of each sentence, and store this vector in the appropriate row of X.


# Load the spacy model: nlp
nlp = spacy.load('en')

# Calculate the length of sentences
n_sentences = len(sentences)

# Calculate the dimensionality of nlp
embedding_dim = nlp.vocab.vectors_length

# Initialize the array with zeros: X
X = np.zeros((n_sentences, embedding_dim))

# Iterate over the sentences
for idx, sentence in enumerate(sentences):
    # Pass each each sentence to the nlp object to create a document
    doc = nlp(sentence)
    # Save the document's .vector attribute to the corresponding row in X
    X[idx, :] = doc.vector
    
    
    
    Intent classification with sklearn
An array X containing vectors describing each of the sentences in the ATIS dataset has been created for you, along with a 1D array y containing the labels. The labels are integers corresponding to the intents in the dataset. For example, label 0 corresponds to the intent atis_flight.

Now, you'll use the scikit-learn library to train a classifier on this same dataset. Specifically, you will fit and evaluate a support vector classifier.

Instructions
100 XP
Import the SVC class from sklearn.svm.
Instantiate a classifier clf by calling SVC with a single keyword argument C with value 1.
Fit the classifier to the training data X_train and y_train.
Predict the labels of the test set, X_test.

# Import SVC
from sklearn.svm import SVC

# Create a support vector classifier
clf = SVC(C= 1)

# Fit the classifier using the training data
clf.fit(X_train,y_train)

# Predict the labels of the test set
y_pred = clf.predict(X_test)

# Count the number of correct predictions
n_correct = 0
for i in range(len(y_test)):
    if y_pred[i] == y_test[i]:
        n_correct += 1

print("Predicted {0} correctly out of {1} test examples".format(n_correct, len(y_test)))


Using spaCy's entity recognizer
In this exercise, you'll use spaCy's built-in entity recognizer to extract names, dates, and organizations from search queries. The spaCy library has been imported for you, and its English model has been loaded as nlp.

Your job is to define a function called extract_entities(), which takes in a single argument message and returns a dictionary with the included entity types as keys, and the extracted entities as values. The included entity types are contained in a list called include_entities.

Instructions
100 XP
Create a dictionary called ents to hold the entities by calling dict.fromkeys() with include_entities as the sole argument.
Create a spacy document called doc by passing the message to the nlp object.
Iterate over the entities in the document (doc.ents).
Check whether the entity's .label_ is one we are interested in. If so, assign the entity's .text attribute to the corresponding key in the ents dictionary.

# Define included_entities
include_entities = ['DATE', 'ORG', 'PERSON']

# Define extract_entities()
def extract_entities(message):
    # Create a dict to hold the entities
    ents = dict.fromkeys(include_entities)
    # Create a spacy document
    doc = nlp(message)
    for ent in doc.ents:
        if ent.label_ in include_entities:
            # Save interesting entities
            ents[ent.label_] = ent.text
    return ents

print(extract_entities('friends called Mary who have worked at Google since 2010'))
print(extract_entities('people who graduated from MIT in 1999'))


Assigning roles using spaCy's parser
In this exercise you'll use spaCy's powerful syntax parser to assign roles to the entities in your users' messages. To do this, you'll define two functions, find_parent_item() and assign_colors(). In doing so, you'll use a parse tree to assign roles, similar to how Alan did in the video.

Recall that you can access the ancestors of a word using its .ancestors attribute.

Instructions
100 XP
Create a spacy document called doc by passing the message "let's see that jacket in red and some blue jeans" to the nlp object.
In the find_parent_item(word) function, iterate over the ancestors of each word until an entity_type() of "item" is found.
In the assign_colors(doc) function, iterate over the doc until an entity_type of "color" is found. Then, find the parent item of this word.
Pass in the spacy document to the assign_colors() function.

# Create the document
doc = nlp("let's see that jacket in red and some blue jeans")

# Iterate over parents in parse tree until an item entity is found
def find_parent_item(word):
    # Iterate over the word's ancestors
    for parent in word.ancestors:
        # Check for an "item" entity
        if entity_type(parent) == "item":
            return parent.text
    return None

# For all color entities, find their parent item
def assign_colors(doc):
    # Iterate over the document
    for word in doc:
        # Check for "color" entities
        if entity_type(word) == "color":
            # Find the parent
            item =  find_parent_item(word)
            print("item: {0} has color : {1}".format(item, word))

# Assign the colors
assign_colors(doc)

Rasa NLU
In this exercise, you'll use Rasa NLU to create an interpreter, which parses incoming user messages and returns a set of entities. Your job is to train an interpreter using the MITIE entity recognition model in Rasa NLU.

Instructions
100 XP
Create a dictionary called args with a single key "pipeline" with value "spacy_sklearn".
Create a config by calling RasaNLUConfig() with the single argument cmdline_args with value args.
Create a trainer by calling Trainer() using the configuration as the argument.
Create a interpreter by calling trainer.train() with the training_data.

# Import necessary modules
from rasa_nlu.converters import load_data
from rasa_nlu.config import RasaNLUConfig
from rasa_nlu.model import Trainer

# Create args dictionary
args = {'pipeline' : "spacy_sklearn"}

# Create a configuration and trainer
config = RasaNLUConfig(cmdline_args = args)
trainer = Trainer(config)

# Load the training data
training_data = load_data("./training_data.json")

# Create an interpreter by training the model
interpreter = trainer.train(training_data)

# Test the interpreter
print(interpreter.parse("I'm looking for a Mexican restaurant in the North of town"))


Data-efficient entity recognition
Most systems for extracting entities from text are built to extract 'Universal' things like names, dates, and places. But you probably don't have enough training data for your bot to make these systems perform well!

In this exercise, you'll activate the MITIE entity recognizer inside Rasa to extract restaurants-related entities using a very small amount of training data. A dictionary args has already been defined for you, along with a training_data object.

Instructions
100 XP
Create a config by calling RasaNLUConfig() with a single argument cmdline_args with value {"pipeline": pipeline}.
Create a trainer and use it to create an interpreter, just as you did in the previous exercise.


# Import necessary modules
from rasa_nlu.config import RasaNLUConfig
from rasa_nlu.model import Trainer

pipeline = [
    "nlp_spacy",
    "tokenizer_spacy",
    "ner_crf"
]

# Create a config that uses this pipeline
config = RasaNLUConfig(cmdline_args = {"pipeline": pipeline})

# Create a trainer that uses this config
trainer = Trainer(config)

# Create an interpreter by training the model
interpreter = trainer.train(training_data)

# Parse some messages
print(interpreter.parse("show me Chinese food in the centre of town"))
print(interpreter.parse("I want an Indian restaurant in the west"))
print(interpreter.parse("are there any good pizza places in the center?"))


SQL basics
Time to begin writing queries for your first hotel booking chatbot! The database has been loaded as "hotels.db" and a cursor, which has access to the database, has already been defined for you as cursor.

Three queries are provided below. Your job is to identify which query returns ONLY the "Hotel California".

You can test each query below by calling the cursor's .execute() method and passing the query in as a string. Then, you can print the results by calling the cursor's .fetchall() method, which takes no arguments.

SELECT name from hotels where price = 'mid' AND area = 'north'



# Import sqlite3
import sqlite3

# Open connection to DB
conn = sqlite3.connect('hotels.db')

# Create a cursor
c = conn.cursor()

# Define area and price
area, price = "south", "hi"
t = (area, price)

# Execute the query
c.execute('SELECT * FROM hotels WHERE area=? AND price=?', t)

# Print the results
print(c.fetchall())



Creating queries from parameters
Now you're going to implement a more powerful function for querying the hotels database. The goal is for that function to take arguments that can later be specified by other parts of your code.

More specifically, your job is to define a find_hotels() function which takes a single argument - a dictionary of column names and values - and returns a list of matching hotels from the database.

Instructions
0 XP
A filters list has been created for you. Join this list together with the strings " WHERE " and " and ".
Create a tuple of the values of the params dictionary.
Create a connection and cursor to "hotels.db" and then execute the query, just as in the previous exercise.
Return the results of the query.

# Define find_hotels()
def find_hotels(params):
    # Create the base query
    query = 'SELECT * FROM hotels'
    # Add filter clauses for each of the parameters
    if len(params) > 0:
        filters = ["{}=?".format(k) for k in params]
        query += " WHERE " + " and ".join(filters)
    # Create the tuple of values
    t = tuple(params.values())
    
    # Open connection to DB
    conn = sqlite3.connect('hotels.db')
    # Create a cursor
    c = conn.cursor()
    # Execute the query
    c.execute(query, t)
    # Return the results
    return c.fetchall()
    
    
    Using your custom function to find hotels
Here, you'll see your find_hotels() function in action! Recall that it accepts a single argument, params, which is a dictionary of column names and values.

Instructions
100 XP
Create the params dictionary with the column names (keys) "area" and "price", with corresponding values "south" and "lo".
Use the find_hotels() function along with your params dictionary to find all inexpensive hotels in the South.

# Create the dictionary of column names and values
params = {'area' : 'south' , 'price' : 'lo'}

# Find the hotels that match the parameters
print(find_hotels(params))


Creating SQL from natural language
Now you'll write a respond() function that can handle messages like "I want an expensive hotel in the south of town" and respond appropriately according to the number of matching results in a database. This is an important functionality for any database-backed chatbot.

Your find_hotels() function from the previous exercises has already been defined for you, along with a Rasa NLU interpreter object, which can handle hotel queries, and a list of responses, which you can explore in the Shell.

Instructions 1/2
50 XP
1
2
Use the .parse() method of interpreter to extract the "entities" in the message.
Find matching hotels using the params dictionary and find_hotels() function.
Use the min() function to choose the right index for the response to send. In this case, n is the number of results.
Select the appropriate response from the responses list and insert the names of hotels using the .format() method.

# Define respond()
def respond(message):
    # Extract the entities
    entities = interpreter.parse(message)["entities"]
    # Initialize an empty params dictionary
    params = {}
    # Fill the dictionary with entities
    for ent in entities:
        params[ent["entity"]] = str(ent["value"])

    # Find hotels that match the dictionary
    results = find_hotels(params)
    # Get the names of the hotels and index of the response
    names = [r[0] for r in results]
    n = min(len(results),3)
    # Select the nth element of the responses array
    return responses[n].format(*names)
    
    
    Excellent! You've built a chatbot that can interpret the results of your hotel DB queries. Now, call the respond() function with the message "I want an expensive hotel in the south of town". Place it inside a call to print() so that you can see the response of your bot in the shell.
    
    
    Refining your search
Now you'll write a bot that allows users to add filters incrementally, just in case they don't specify all of their preferences in one message.

To do this, initialize an empty dictionary params outside of your respond() function (as opposed to inside the function, like in the previous exercise). Your respond() function will take in this dictionary as an argument.

Instructions
100 XP
Instructions
100 XP
Define a respond() function that accepts two arguments - a message and a dictionary of params - and returns two results - the message to send to the user and the updated params dictionary.
Extract "entities" from the message using the .parse() method of the interpreter, exactly like you did in the previous exercise.
Find the hotels that match params using your find_hotels() function.
Initialize the params dictionary outside the respond() function and hit 'Submit Answer' to pass the messages to the bot.


# Define a respond function, taking the message and existing params as input
def respond(message, params):
    # Extract the entities
    entities = interpreter.parse(message)["entities"]
    # Fill the dictionary with entities
    for ent in entities:
        params[ent["entity"]] = str(ent["value"])

    # Find the hotels
    results = find_hotels(params)
    names = [r[0] for r in results]
    n = min(len(results), 3)
    # Return the appropriate response
    return responses[n].format(*names), params

# Initialize params dictionary
params = {}

# Pass the messages to the bot
for message in ["I want an expensive hotel", "in the north of town"]:
    print("USER: {}".format(message))
    response, params = respond(message, params)
    print("BOT: {}".format(response))
    
    
    Basic negation
Quite often, you'll find your users telling you what they don't want - and that's important to understand! In general, negation is a difficult problem in NLP. Here, we'll take a very simple approach that works for many cases.

A list of tests called tests has been defined for you. Explore it in the Shell - you'll find that each test is a tuple consisting of:

A string containing a message with entities.
A dictionary containing the entities as keys and a Boolean saying whether they are negated as the key.
Your job is to define a function called negated_ents() which looks for negated entities in a message.

Instructions
100 XP
Using list comprehension, check if the words "south" or "north" appear in the message and extract those entities.
Split the sentence into chunks ending with each entity. To do this:
Use the .index() method of phrase to find the starting index of each entity e and add the entity's length to it to find the index of the end of the entity.
Starting with start=0, take slices of the string from start to end for each end in ends. Append each slice of the sentence to the list, chunks. Ensure you update your starting position with each iteration.
For each entity, if "not" or "n't" appears in the chunk, consider this entity negated.


# Define negated_ents()
def negated_ents(phrase):
    # Extract the entities using keyword matching
    ents = [e for e in ["south", "north"] if e in phrase]
    # Find the index of the final character of each entity
    ends = sorted([phrase.index(e) + len(e) for e in ents])
    # Initialise a list to store sentence chunks
    chunks = []
    # Take slices of the sentence up to and including each entitiy
    start = 0
    for end in ends:
        chunks.append(phrase[start:end])
        start = end
    result = {}
    # Iterate over the chunks and look for entities
    for chunk in chunks:
        for ent in ents:
            if ent in chunk:
                # If the entity contains a negation, assign the key to be False
                if "not" in chunk or "n't" in chunk:
                    result[ent] = False
                else:
                    result[ent] = True
    return result  

# Check that the entities are correctly assigned as True or False
for test in tests:
    print(negated_ents(test[0]) == test[1])
    
    
    
    Filtering with excluded slots
Now you're going to put together some of the ideas from previous exercises in order to allow users to tell your bot about what they do and do not want, split across multiple messages.

The negated_ents() function has already been defined for you. Additionally, a slightly tweaked version of the find_hotels() function, which accepts a neg_params dictionary in addition to a params dictionary, has been defined.

Instructions
100 XP
Define a respond() function which accepts a message, params, and neg_params as arguments.
Use the negated_ents() function with message and ent_vals as arguments. Store the result in negated.
Use the tweaked find_hotels() function with the params and neg_params dictionaries as arguments to find matching hotels. Store the result in results.
Initialize the params and neg_params dictionaries outside the respond() function and hit 'Submit Answer' to see the bot's responses!


# Define the respond function
def respond(message,params,neg_params):
    # Extract the entities
    entities = interpreter.parse(message)["entities"]
    ent_vals = [e["value"] for e in entities]
    # Look for negated entities
    negated = negated_ents(message,ent_vals)
    for ent in entities:
        if ent["value"] in negated and negated[ent["value"]]:
            neg_params[ent["entity"]] = str(ent["value"])
        else:
            params[ent["entity"]] = str(ent["value"])
    # Find the hotels
    results = find_hotels(params, neg_params)
    names = [r[0] for r in results]
    n = min(len(results),3)
    # Return the correct response
    return responses[n].format(*names), params, neg_params

# Initialize params and neg_params
params = {}
neg_params = {}

# Pass the messages to the bot
for message in ["I want a cheap hotel", "but not in the north of town"]:
    print("USER: {}".format(message))
    response, params, neg_params = respond(message, params, neg_params)
    print("BOT: {}".format(response))
    
    
  # Define the INIT state
INIT = 0

# Define the CHOOSE_COFFEE state
CHOOSE_COFFEE = 1

# Define the ORDERED state
ORDERED = 2

# Define the policy rules
policy = {
    (INIT, "order"): (CHOOSE_COFFEE, "ok, Colombian or Kenyan?"),
    (INIT, "none"): (INIT, "I'm sorry - I'm not sure how to help you"),
    (CHOOSE_COFFEE, "specify_coffee"): (ORDERED, "perfect, the beans are on their way!"),
    (CHOOSE_COFFEE, "none"): (CHOOSE_COFFEE, "I'm sorry - would you like Colombian or Kenyan?"),
}

# Create the list of messages
messages = [
    "I'd like to become a professional dancer",
    "well then I'd like to order some coffee",
    "my favourite animal is a zebra",
    "kenyan"
]

# Call send_message() for each message
state = INIT
for message in messages:    
    state = send_message(policy, state, message)
    
    
    Asking contextual questions
Sometimes your users need some help! They will have questions and expect the bot to help them.

In this exercise, you'll allow users to ask the coffee bot to explain the steps to them. As in the previous exercise, the answer they get will depend on where they are in the flow.

Instructions
100 XP
Add two rules to your policy_rules to handle the intent "ask_explanation" when in the states INIT or CHOOSE_COFFEE.
Inside the send_messages() function, call the send_message() function with state and msg as arguments to define the new state. Then, hit 'Submit Answer' to send the messages and see the bot's responses.


# Define the states
INIT=0 
CHOOSE_COFFEE=1
ORDERED=2

# Define the policy rules dictionary
policy_rules = {
    (INIT, "ask_explanation"): (INIT, "I'm a bot to help you order coffee beans"),
    (INIT, "order"): (CHOOSE_COFFEE, "ok, Colombian or Kenyan?"),
    (CHOOSE_COFFEE, "specify_coffee"): (ORDERED, "perfect, the beans are on their way!"),
    (CHOOSE_COFFEE, "ask_explanation"): (CHOOSE_COFFEE, "We have two kinds of coffee beans - the Kenyan ones make a slightly sweeter coffee, and cost $6. The Brazilian beans make a nutty coffee and cost $5.")    
}

# Define send_messages()
def send_messages(messages):
    state = INIT
    for msg in messages:
        state = send_message(state,msg)

# Send the messages
send_messages([
    "what can you do for me?",
    "well then I'd like to order some coffee",
    "what do you mean by that?",
    "kenyan"
])



Dealing with rejection
What happens if you make a suggestion to your user and they don't like it? Your bot will look really silly if it makes the same suggestion again right away.

Here, you're going to modify your respond() function so that it accepts and returns 4 arguments:

The user message as an argument, and the bot response as the first return value.
A dictionary params including the entities the user has specified.
A prev_suggestions list. When passed to respond(), this should contain the suggestions made in the previous bot message. When returned by respond(), it should contain the current suggestions.
An excluded list, which contains all of the results your user has already explicitly rejected.
Your function should add the previous suggestions to the excluded list whenever it receives a "deny" intent. It should also filter out excluded suggestions from the response.

Instructions
100 XP
Define a respond() function with 4 arguments: message, params, prev_suggestions, and excluded.
Interpret the message and store the result in parse_data.
The value of the "intent" key of parse_data is itself a dictionary of key-value pairs. Assign parse_data["intent"]["name"] to intent, and parse_data["entities"] to entities.
If the intent is "deny", use the .extend() method of the excluded list to add prev_suggestions to it.
Initialize the empty params dictionary and empty suggestions and excluded lists. Then, hit 'Submit Answer' to send the messages to the bot.



# Define respond()
def respond(message,params,prev_suggestions,excluded):
    # Interpret the message
    parse_data = interpret(message)
    # Extract the intent
    intent = parse_data["intent"]["name"]
    # Extract the entities
    entities = parse_data["entities"]
    # Add the suggestion to the excluded list if intent is "deny"
    if intent == "deny":
        excluded.extend(prev_suggestions)
    # Fill the dictionary with entities	
    for ent in entities:
        params[ent["entity"]] = str(ent["value"])
    # Find matching hotels
    results = [
        r 
        for r in find_hotels(params, excluded) 
        if r[0] not in excluded
    ]
    # Extract the suggestions
    names = [r[0] for r in results]
    n = min(len(results), 3)
    suggestions = names[:2]
    return responses[n].format(*names), params, suggestions, excluded

# Initialize the empty dictionary and lists
params, suggestions, excluded = {}, [], []

# Send the messages
for message in ["I want a mid range hotel", "no that doesn't work for me"]:
    print("USER: {}".format(message))
    response, params, suggestions, excluded = respond(message, params, suggestions, excluded)
    print("BOT: {}".format(response))
    
    
    
    
    Pending actions I
You can really improve the user experience of your bot by asking the user simple yes or no follow-up questions. One easy way to handle these follow-ups is to define pending actions which get executed as soon as the user says "yes", and wiped if the user says "no".

In this exercise, you're going to define a policy() function which takes the intent as its sole argument and returns two values: The next action to take and a pending action. The policy function should return this pending action when a "yes" or "affirm" intent is returned and should wipe the pending actions if a "no" or "deny" intent is returned.

Here, the interpret(message) function has been defined for you such that if "yes" is in the message, "affirm" is returned, and if "no" is in the message, then "deny" is returned.

Instructions
100 XP
Define a function called policy() which takes intent as its argument.
If the intent is "affirm", return a "do_pending" action and None.
If the intent is "deny", return a "Ok" action and None.




# Define policy()
def policy(intent):
    # Return "do_pending" if the intent is "affirm"
    if intent == "affirm":
        return "do_pending", None
    # Return "Ok" if the intent is "deny"
    if intent == "deny":
        return "Ok", None
    if intent == "order":
        return "Unfortunately, the Kenyan coffee is currently out of stock, would you like to order the Brazilian beans?", "Alright, I've ordered that for you!"
        
        
  
  
  
  
  
  Pending actions II
Having defined your policy() function, it's now time to write a send_message() function which takes both a pending action and a message as its arguments and leverages the policy() function to determine the bot's response.

Your policy(intent) function from the previous exercise has been pre-loaded.

Instructions
100 XP
Define a function called send_message() which takes in two arguments: pending and message.
Pass in the interpretation of message as an argument to policy() and unpack the result into the variables action and pending_action.
If the action is "do_pending" and pending is not None, print the pending response. Else, print the action.
Inside the definition of the send_messages() function, call your send_message() function with pending and msg as arguments. Then, hit 'Submit Answer' to send the messages and see the results.





Pending state transitions
You'll often need to briefly deviate from the flow of a conversation, for example to authenticate a user, before returning to the topic of discussion.

In these cases, it's often simpler - and easier to debug - if you save some actions/states as pending rather than adding ever more complicated rules.

Here, you're going to define a policy_rules dictionary, where the keys are tuples of the current state and the received intent, and the values are tuples of the next state, the bot's response, and a state for which to set a pending transition.

Instructions
100 XP
Complete the policy_rules dictionary by filling in the values:
A user starts in the INIT state.
If the user is in the INIT state and tries to place an order, you should ask for their number and create a pending transition to the AUTHED state.
This is the only policy rule which creates a pending transition, so the others simply have a pending state value of None.
The pending state has been added as the second argument of the send_message() function, which now returns the new state as well as the pending state. Call this send_message() function inside send_messages(), unpacking the output into the variables state and pending.
Hit 'Submit Answer' to send the messages to the bot!


# Define the states
INIT=0
AUTHED=1
CHOOSE_COFFEE=2
ORDERED=3

# Define the policy rules
policy_rules = {
    (INIT, "order"): (INIT, "you'll have to log in first, what's your phone number?", AUTHED),
    (INIT, "number"): (AUTHED, "perfect, welcome back!", None),
    (AUTHED, "order"): (CHOOSE_COFFEE, "would you like Colombian or Kenyan?", None),    
    (CHOOSE_COFFEE, "specify_coffee"): (ORDERED, "perfect, the beans are on their way!", None)
}

# Define send_messages()
def send_messages(messages):
    state = INIT
    pending = None
    for msg in messages:
        state, pending = send_message(state, pending, msg)

# Send the messages
send_messages([
    "I'd like to order some coffee",
    "555-1234",
    "kenyan"
])


Putting it all together I
It's time to put everything you've learned in the course together by combining the coffee ordering bot with the ELIZA rules from chapter 1.

To begin, you'll define a function called chitchat_response(), which calls the predefined function match_rule() from back in chapter 1. This returns a response if the message matched an ELIZA template, and otherwise, None.

The ELIZA rules are contained in a dictionary called eliza_rules.

Instructions
100 XP
Define a chitchat_response() function which takes in a message argument.
Call the match_rule() function with eliza_rules and message as arguments. Unpack the output into response and phrase.
If the response is "default", return None.
If "{0}" is in the response, replace the pronouns of the phrase using replace_pronouns(), and then include the phrase in the response by using .format() on response.



# Define chitchat_response()
def chitchat_response(message):
    # Call match_rule()
    response, phrase = match_rule(eliza_rules,message)
    # Return none if response is "default"
    if response == "default":
        return None
    if '{0}' in response:
        # Replace the pronouns of phrase
        phrase = replace_pronouns(phrase)
        # Calculate the response
        response = response.format(phrase)
    return response
    
    
    
    
    Putting it all together II
With your chitchat_response(message) function defined, the next step is to define a send_message() function. This function should first call chitchat_response(message) and only use the coffee bot policy if there is no matching message.

Instructions

Define a send_message() function which takes in 3 arguments: state, pending, and message.
Call chitchat_response(message), storing the result in response. If there is a response, print it and return the state along with None.
Unpack the policy_rules dictionary into the variables new_state, response, and pending_state. To do this, pass in a tuple consisting of state and interpret(message).
If pending is not none, extract the new states and response by using pending as the key of policy_rules.


# Define send_message()
def send_message(state, pending, message):
    print("USER : {}".format(message))
    response = chitchat_response(message)
    if response is not None:
        print("BOT : {}".format(response))
        return state, None
    
    # Calculate the new_state, response, and pending_state
    new_state, response, pending_state = policy_rules[(state, interpret(message))]
    print("BOT : {}".format(response))
    if pending is not None:
        new_state, response, pending_state = policy_rules[pending]
        print("BOT : {}".format(response))        
    if pending_state is not None:
        pending = (pending_state, interpret(message))
    return new_state, pending

# Define send_messages()
def send_messages(messages):
    state = INIT
    pending = None
    for msg in messages:
        state, pending = send_message(state, pending, msg)

# Send the messages
send_messages([
    "I'd like to order some coffee",
    "555-12345",
    "do you remember when I ordered 1000 kilos by accident?",
    "kenyan"
])  


Generating text with neural networks
In this final exercise of the course, you're going to generate text using a neural network trained on the scripts of every episode of The Simpsons. Specifically, you'll use a simplified version of the sample_text() function that Alan described in the video.

It takes in two arguments: seed and temperature. The seed argument is the initial sequence that the network uses to generate the subsequent text, while the temperature argument controls how risky the network is when generating text. At very low temperatures, it just repeats the most common combinations of letters, and at very high temperatures, it generates complete gibberish. In order to ensure fast runtimes, the network in this exercise will only work for a subset of temperature values.

After you finish this exercise, be sure to check out this tutorial by Alan where he walks you through how to connect a chatbot to Facebook Messenger!

Instructions
100 XP
Set the seed to be "i'm gonna punch lenny in the back of the".
For each of the riskiness values [0.2, 0.5, 1.0, 1.2], call the sample_text() function with the arguments seed and temperature.


# Feed the seed text into the neural network
seed = "i'm gonna punch lenny in the back of the"

# Iterate over the different temperature values
for temperature in [0.2, 0.5, 1.0, 1.2]:
    print("\nGenerating text with riskiness : {}\n".format(temperature))
    # Call the sample_text function
    print(sample_text(seed,temperature))
